# Protocol

The protocol provides support for mapping a request to a method declared on a handler. It also 
features role-based access control through an AuthorizationHandler.

Javadoc can be found [here](javadoc/com/codingchili/core/protocol/package-summary.html).

The dynamic invocation when using annotations uses ReflectASM and is pretty fast. If the programmatic
API is used instead, reflection will not be used at all.

### Registering a protocol
There are two ways of creating a protocol mapping, lets create the protocol instance first.

```$java
private Protocol<Request> protocol = new Protocol<>();
```

Then we need to set up some mappings and the default role for the API.

##### Annotations
Annotations can be used to simplify the mapping.
 
Setting the default `Role` required for the api to `USER` and mapping a method to a route called `list`.

```$java
@Roles(USER)
public class MyHandler implements CoreHandler {

    @Api
    public void list(Request request) {
        request.write(someList);
    }
}
``` 

##### Programmatically
Programmatic registration is more dynamic and a tiny bit faster at runtime.

```$java
protocol.setRoles(Role.USER)
        .use("ROUTE", this::list)
        .use("ROUTE", this::listAsAdmin, Role.ADMIN);
```

### Authentication
Authentication is required by default for all routes as Role.USER.

##### Strategy
The `@Authenticator` annotation can be applied to a function with the signature
`Function<Request, Future<RoleType>>`, which maps a request into a role. If the user is not
authorized, then the RoleType of `PUBLIC` is used. It's also possible to define custom role types.

```$java
@Authenticator
public Future<RoleType> authenticator(Request request) {
    Future<RoleType> future = Future.future();
    
    tokenFactory.verify(request.token()).setHandler(verify -> {
        if (verify.succeeded()) {
            future.complete(Role.USER);
        } else {
            future.complete(Role.PUBLIC);
        }
    });
    return future;
}
```

For the authenticator to be registered in the protocol the handler needs to be annotated and the handler
passed to the `Protocol` constructor or registered with the `Protocol.annotated(handler)` method.

If annotations are not being used, the authenticator can be set with the following,

```$java
protocol.authenticator(this::authenticator);
``` 

##### Levels

When resolving the access level for a route, the max level of all the current principals roles is used by the default
authorizer. This does not allow for granular permission schemes but it's very simple. 

Custom roles can be defined, they need to implement the `RoleType` interface and be added to
the `RoleMap`.

Example of creating a custom role

```$java
public SuperRootRole implements RoleType {
    
    public String getName() {
        return "super root role";
    }
    
    public int getLevel() {
        return Integer.MAX_VALUE;
    }
}
```

Registering the role in the `RoleMap`,

```$java
RoleMap.put("super_root", new SuperRootRole());
```

In order to provide more advanced authorization models, the authorization handler can be replaced in the protocol.

This is done by calling
```$java
protocol.setAuthorizationHandler(customHandler);
```

The interface to implement, [AuthorizationHandler](javadoc/com/codingchili/core/protocol/AuthorizationHandler.html).

### Processing
Processing is the invocation of a mapped method, it's initiated from the `CoreHandler::handle` method.

```$java
public void handle(Request request) {
    protocol.process(request);
}
```

This handles authorization and error handling internally within the protocol.

### Documenting the API
Programmatically documenting

```$java
protocol
    .model(DefaultModel.class)
    .description("this is the API")
    .use("wowza", this::wowza)
        .description("does the wowza.")
        .model(Wowza.class);
```

Alternatively, with annotations

```$java
@Description("this is the API")
@DataModel(Wowza.class)
public class MyHandler implements CoreHandler {

    @Api
    @Description("does the wowza.")
    @DataModel(Wowza.class)
    public void wowza(Request request) {
        request.accept();
    }

}
```
The annotation based setup requires that either the handler is passed to the `protocol` constructor or that 
`protocol.annotated(handler)` is called. 

When a protocol is documented the protocol will automatically add a route for retrieving a the specification in a custom 
format generated by the `Serializer.describe(class)` method.

Note that it is possible to mix the annotated and programmatic setup on the same protocol instance. 
It is also possible to register multiple classes onto the same protocol.

- It's currently not possible to generate any OpenAPI definitions from an API. (wink wink new PR?)


##### Example

The current format looks like this, from zapperfly-asm.

```$yaml
model:
  request: "com.codingchili.core.listener.Request"
text: "Handles configuration and build requests."
routes:
- model: {}
  description: "Cancels a scheduled build"
  role:
  - "USER"
  name: "cancel"
- model: {}
  description: "Schedules a new build on the given repo and branch."
  role:
  - "PUBLIC"
  name: "submit"
- model: {}
  description: "Retrieves the build log for the running build with the given line\
    \ offset."
  role:
  - "USER"
  name: "log"
- model: {}
  description: "Lists all executors/instances that has joined the cluster at some\
    \ point."
  role:
  - "PUBLIC"
  name: "instances"
- model: {}
  description: "Lists all jobs that have been queued."
  role:
  - "PUBLIC"
  name: "queued"
- model: {}
  description: "Clears the build history"
  role:
  - "ADMIN"
  name: "clear"
- model: {}
  description: "Lists all builds that has been executed on the server."
  role:
  - "PUBLIC"
  name: "list"
- model: {}
  description: "Deletes the build files for the given job."
  role:
  - "USER"
  name: "remove"
- model: {}
  description: "Lists artifacts available for download."
  role:
  - "USER"
  name: "artifacts"
- model: {}
  description: "Returns the build status for the given build ID without the build\
    \ log."
  role:
  - "PUBLIC"
  name: "status"
```

The documentation feature is a work in progress obviously :)